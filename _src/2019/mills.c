

             #/*void*/include<math.h>
     #include/*#pragma _Atomic int*/<stdio.h>
/*       { */struct{ int o,s; } typedef V       ;
struct{      int x; V o,i,p; }typedef      R; int
d,w,a,i,b,      u,g,n,j,F,h; R*Q,B      [99],*E=B
; V I(int s ){     V o={ d,s} ;     d +=s; return
#define O ; { } }     if(! n     --) { { {  ; } }
o; } float*p,ll=1,*     q,     *e,s,*r,*G,*W,y=1,
# define _ V i ){ V o=      I(i .s); * E++=( R) {
*x,l,*z,m; V A(V p,_ 4,o    ,p,i} ; return o; } V
X,Y; double drand48(); V C    (V i,V o){ *E++=(R)
#define OO ){ P(Q->o,a=Q->i.    o-n; b=Q->p .o-n\
; r=b+W+n){ { n=Q->x O//struct   volatile union {
{ 3,o,i} ; return o; } unsigned    char c[256],t[
sizeof c+N]; V M(V p,_ 5,o,p,i} ;   return  o ; }
struct{ float r ; short k ,p; char    unsigned d[
sizeof c]; } k={ LR} ; V S(_ 2,o,i}    ; return o
; } void Z(float*p,int n){ while(n--)   *p++=0; }
V L(int s,V i){ V o=I(s),p={ w,s+i.s*s   } ; w+=p
#define P(v,i)n=v.o; e=G+n; p=e+v.s; q=   p+d; i\
; while(--q,p-->e)// _Alignas _Imaginary   _Bool;
.s; *E++=(R){0,o,i,p}; return o; } V CM(V   i){ V
 o=I(a=i.s),p={ w,a} ; w+=a; *E++=(R){ 7,    o,i,
p} ; return o; } void J(int c){ Z(e=G+X.o,   X.s)
; c[e]++ ; for(Q=B; Q<E; ++Q OO*p=*r++; n=Q   ->i
.s; while(n--)*p+=*r++*e[a+n]O*p=tanh(a[p])   O*p
=1/(exp(-a[p])+1)O p[a+u]=*p O*p=p[a]+b[p]O*   p=
a[p]*p[b]O*p=a[p ]*Q->p.s+Q->p.o O*p=a[p]**r   ++
; } } } Z(G+d,d); P(Y,m=*e)m=fmax(m,*p); P(Y,   s
=0)s+=*q=exp((*p-m)/TP); P(Y, )*q/=s; } V T(_   1
,o,i}; return o; } int K(int K ){ J(K); P(Y,s   =
drand48( ))if((s-=*q)<0)break; return j=p-e; }
V OG(int a,int b,_ 6,o,(V){ b,a} } ; return o;
} void D(char unsigned*s){ float V[2*d]; int R
=u; u=V-G; J(c[*s++ ]); n=c[*s]; l-=log(n[++q]
--)/N; G+=u; p=d+G; if(1[s])D(s); else while(p
-->G){ p[x-G]=*p; d[p]=0; } G-=u; Q=E; while(F
<i&&Q-->B OO r++[w ]+=*q; n=Q->i .s; z=e+a +n;
while(n--){ w[r ]+=*q**--z; d[z]+=*q**r++; } O
a[q]+=*q*(1-*p**p)O q[a]+=*q*(1-*p)**p O*q+=q   [
a+u]O a[q]+=*q; q[b]+=*q O q[a]+=b[p]**q; b[q   ]
+=p[a ]**q O a[q ]+=Q->p.s**q O a[q ]+=*q**r;   r
++[w]+=*q**p; } } } u=R; } V MD( V x){ V BK;   //
return y; } int main(int Q,char**E){ FILE*f,   *o
=stdin; if(--Q){ o=fopen(2[E],"r"); f=fopen   (1[
E],"r"); while(w>-(n=getc(f))){ ++h; if(!n[   t])
{ n[t]++; k.d[k.k]=n; n[c]=k .k++; } } } o   &&f\
read(&k,sizeof k,1,o); n=k.k; { V NW; X=x    ; Y=
y; } float R[d+d],B[4*w],q[d*2]; G=x=R; W   =B; Z
(W,4*w); p=W+w; while(p-->W)*p=2*drand48   ()*RS-
RS; o&&fread(W,1,sizeof B,o); Z(G,d); h   /=N; i=
h*TR; h-=i; for(t[1+N]=m; Q; fclose(o)   ){ rewi\
nd(f ); while(fread(t,1 +N,1,f) ){ G=   q; p=d+G;
while(p-->G)*p=p[x-G]; D(t); ungetc    (j=N[t],f)
; if(F++<i){ a=w*3; b=a- w; p=W+w;    while(p-->W
){ m=fmax(-CL,fmin(CL,w[p ])); ll   *=B1; p[a]=m+
(a[p]-m)*B1; y*=B2; m*=m; b[p]=    m+(p[b]-m)*B2;
*p+=(a[p]/sqrt(p[b]/(1-y)+EP)/   (ll-1)+WD**p)*k.
r; p[w]=0; } if(1>F%DI){ G=R    ; z=SL+W; while(z
-->B)putchar(k.d[K(j)]); }    } if(1>F%DI ){ b=F;
a=i; j=b>a; if(j){ b-=a;    a= h; } printf(&j[//;
"\n%c%d:%d%% %f\n"],j[      "TV"],k.p,100*b/a,l/b
); } l*=F!=i; } /**     */     char p[999]; if(LE
<=++k .p)k.r*=LD;     /*if*/     sprintf(p,PF,k.p
,l/h); fwrite(     &k,sizeof k,     1,o =fopen(p,
"w")); F=l      =0; fwrite(B,w,/**      */sizeof*
W,o); }      while(putchar(k.d[K(j)])      ){ } }
/*       typedef volatile long double not       ;
     register restrict unsigned volatile void
             _Complex struct bitand*/

