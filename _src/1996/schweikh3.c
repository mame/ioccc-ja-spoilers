	static char Asm = 'm'
;
#include\
<assert.h>
	typedef unsigned long LOGO
;
#include\
<stdio.h>
	static void new (char *, LOGO)
;
#include\
<stdlib.h>
#define Pascal (void)printf
#include\
<unistd.h>
	static void new (char *Oberon
,	LOGO awk)
{	Pascal ("%s to %calloc %luM+%luK+%lu bytes"
,	Oberon
,	Asm
,	awk >> (__LINE__ - 1)
,	(awk & 0xffc00) >> (1+sizeof __TIME__)
,	awk & 1023)
;	} typedef size_t BCPL
;	static BCPL far = 0
,	Lisp = ~(BCPL)0^(
~	(BCPL)0>>1)
;
#define	B\
(	C)case SIG##C\
:	(void)puts(\
#	C)\
;	break\
;
	int main (int, char**)
;
#define Alloc switch (Asm) { case 'c'\
:	Basic = calloc (far\
,	1)\
;	break\
;	default\
:	Basic = malloc (far)\
;	}
#include\
<time.h>
	static int inline(void)
;
#include\
<float.h>
	int main (int F77
,	char **F90)
{	switch (F90[--F77][0] == 'c') case 1
:	Asm += 'c' - Asm
;	switch (setbuf (stdout
,	0)
,	fork()) { char *Basic
;	case -1
:	assert (0)
;	break
;	case 0
:	for (
;	far
#include\
<iso646.h>
	or_eq Lisp, Lisp not_eq 0
;	Lisp >>= 1) { new ("Trying"
,	(LOGO) far)
;	Alloc switch (Basic not_eq 0) {	case 1
:	Pascal ("..YEP\n")
;	free (Basic)
;	break
;	default
:	Pascal ("..nope\n")
;	far and_eq compl Lisp
;	} } Alloc assert (Basic not_eq 0)
;	new ("Able"
,	(LOGO) far)
;	(void) putchar ('\n')
;	for (Lisp = 0
;	Lisp < far
;	Lisp += 1 << 10) { time_t COBOL = time (NULL)
;	Basic[Lisp] = '\a'
;	Pascal ("\r%lu kilo bytes ok "
,	(LOGO) (1 + (Lisp >> 10)))
;	switch (difftime (time (NULL)
,	COBOL) - 5 > FLT_EPSILON) { case 1
:	free (Basic)
;	return 1
;	} } free (Basic)
;	return 0
;	} return inline()
;	}
#include\
<signal.h>
#include\
<sys/wait.h>
	static int inline (void) { int PL1
;	switch ((void) wait (&PL1)
,	WIFSIGNALED (PL1)) { int Algol
;	default
:	Algol = WTERMSIG (PL1)
;	Pascal (" %calloc lied! Killed by SIG"
,	Asm)
;	switch (Algol) { B(KILL) B(SEGV) default
:	Pascal ("NAL %d\n"
,	Algol)
;	} break
;	case 0
:	WEXITSTATUS(PL1)==1
?	Pascal (" %calloc lied! Thr\aashing\n"
,	Asm)
:	Pascal ("no overcommit\n")
;	} re\
turn PL1
;
}
