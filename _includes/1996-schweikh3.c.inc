	static char Asm = &#39;m&#39;
;
#include\
&lt;assert.h&gt;
	typedef unsigned long LOGO
;
#include\
&lt;stdio.h&gt;
	static void new (char *, LOGO)
;
#include\
&lt;stdlib.h&gt;
#define Pascal (void)printf
#include\
&lt;unistd.h&gt;
	static void new (char *Oberon
,	LOGO awk)
{	Pascal (&quot;%s to %calloc %luM+%luK+%lu bytes&quot;
,	Oberon
,	Asm
,	awk &gt;&gt; (__LINE__ - 1)
,	(awk &amp; 0xffc00) &gt;&gt; (1+sizeof __TIME__)
,	awk &amp; 1023)
;	} typedef size_t BCPL
;	static BCPL far = 0
,	Lisp = ~(BCPL)0^(
~	(BCPL)0&gt;&gt;1)
;
#define	B\
(	C)case SIG##C\
:	(void)puts(\
#	C)\
;	break\
;
	int main (int, char**)
;
#define Alloc switch (Asm) { case &#39;c&#39;\
:	Basic = calloc (far\
,	1)\
;	break\
;	default\
:	Basic = malloc (far)\
;	}
#include\
&lt;time.h&gt;
	static int inline(void)
;
#include\
&lt;float.h&gt;
	int main (int F77
,	char **F90)
{	switch (F90[--F77][0] == &#39;c&#39;) case 1
:	Asm += &#39;c&#39; - Asm
;	switch (setbuf (stdout
,	0)
,	fork()) { char *Basic
;	case -1
:	assert (0)
;	break
;	case 0
:	for (
;	far
#include\
&lt;iso646.h&gt;
	or_eq Lisp, Lisp not_eq 0
;	Lisp &gt;&gt;= 1) { new (&quot;Trying&quot;
,	(LOGO) far)
;	Alloc switch (Basic not_eq 0) {	case 1
:	Pascal (&quot;..YEP\n&quot;)
;	free (Basic)
;	break
;	default
:	Pascal (&quot;..nope\n&quot;)
;	far and_eq compl Lisp
;	} } Alloc assert (Basic not_eq 0)
;	new (&quot;Able&quot;
,	(LOGO) far)
;	(void) putchar (&#39;\n&#39;)
;	for (Lisp = 0
;	Lisp &lt; far
;	Lisp += 1 &lt;&lt; 10) { time_t COBOL = time (NULL)
;	Basic[Lisp] = &#39;\a&#39;
;	Pascal (&quot;\r%lu kilo bytes ok &quot;
,	(LOGO) (1 + (Lisp &gt;&gt; 10)))
;	switch (difftime (time (NULL)
,	COBOL) - 5 &gt; FLT_EPSILON) { case 1
:	free (Basic)
;	return 1
;	} } free (Basic)
;	return 0
;	} return inline()
;	}
#include\
&lt;signal.h&gt;
#include\
&lt;sys/wait.h&gt;
	static int inline (void) { int PL1
;	switch ((void) wait (&amp;PL1)
,	WIFSIGNALED (PL1)) { int Algol
;	default
:	Algol = WTERMSIG (PL1)
;	Pascal (&quot; %calloc lied! Killed by SIG&quot;
,	Asm)
;	switch (Algol) { B(KILL) B(SEGV) default
:	Pascal (&quot;NAL %d\n&quot;
,	Algol)
;	} break
;	case 0
:	WEXITSTATUS(PL1)==1
?	Pascal (&quot; %calloc lied! Thr\aashing\n&quot;
,	Asm)
:	Pascal (&quot;no overcommit\n&quot;)
;	} re\
turn PL1
;
}