---
id: 2013/endoh1
year: 2013
order: 5
authors: "Yusuke_Endoh"
orig_url: "https://www.ioccc.org/2013/endoh1/endoh1.c"
hint_url: "https://www.ioccc.org/2013/endoh1/hint.html"
title: "IOCCC 2013: Most lazy SKIer"
award_ja: "もっとも怠惰なスキーヤー"
---

## 動作

[Lazy K](https://ja.wikipedia.org/wiki/Lazy_K)のインタプリタ。

Lazy Kのソースコードを普通に読み込むのではなく、Lazy Kのコードの最初と最後でendoh1.cを`#include`してコンパイルすることで、Lazy Kのプログラムを実行する。

たとえば次は、Lazy Kのソースコードの例。

```
#include "endoh1.c"

K(S(S I(K(S(K(S I I(S(S(K S)K)I)))(S(S(K S)K)(S(S(K S)K)(S(S I I)I(S(S(K S)K)I)))))))(K(S(S I(K(S(S(K S)K)(S(S(K S)K)I(S(K(S(S(K S)K)I))(S(S(K S)K)(S I I(S(S(K S)K)I))))))))(K(S(S(K S)(S(K(S I))K))(S(K K)(S(S(K S)(S(K(S I))K))(S(K K)(S(S(K S)(S(K(S I))(S(K K)(S(S I(K(S(S(K S)K))))(K(S(S(K S)K)(S(S(K S)K)I)))))))(K(K(S(S I(K(S(S(K S)K)(S(S I I)I(S(S(K S)K)I))(S(S(K S)K))(S I I(S(S(K S)K)(S(S(K S)K)I))))))(K(S(S I(K(S(K(S(S(K S)K)I))(S(S I I)I(S(S(K S)K)I)))))(K(S(S I(K(S(S(K S)K)(S(K(S I I(S(S(K S)K)I)))(S(S(K S)K)(S(S(K S)K)(S(S I I)I(S(S(K S)K)I))))))))(K(S(S I(K(S(S(K S)K)(S(K(S(S(K S)K)(S(S(K S)K)I)))(S(S(K S)K)(S(S(K S)K)I(S(S(K S)K)(S I I(S(S(K S)K)I)))))))))(K(S(S(K S)(S(K(S I))K))(S(K K)(S(S(K S)(S(K(S I))K))(S(K K)(S(S(K S)(S(K(S I))K))(K(K(S(S I(K(S(S(K S)K)(S(K(S(S(K S)K)I))(S(S I I)I(S(S(K S)K)I))))))(K(S(S I(K(S(K(S(S(K S)K)I))(S(S(K S)K)(S I I(S(S(K S)K)I))))))(K(S(S I(K(S I I(S I I(S(S(K S)K)I)))))(K S))))))))))))(S(S(K S)K)(S(S(K S)K)(S(S(K S)K)(S(S(S(K S)K))(S I I)(S(S(K S)K)I))))))))))))))))))))(S(K(S I I(S(S(K S)K)I)))(S I I(S(S(K S)K)(S(S(K S)K)I)))))))))

#include "endoh1.c"
```

普通のLazy Kのインタプリタ、たとえば[irori/lazyk](https://github.com/irori/lazyk)で実行すると次のようになる（`#`で始まる行はLazy Kではコメントなので無視されている）。

```
$ ./lazyk hello.lazy
Hello, IOCCC!
```

そして、`#include "endoh1.c"`で挟んであるので、C言語コードとしてコンパイル・実行しても同じ動作をする。

```
$ gcc -o hello -xc hello.lazy

$ ./hello
Hello, IOCCC!
```

---

なお、endoh1.c単体をコンパイル・実行すると、次のようなメッセージを表示する。

```
$ ./endoh1
@@@@@
@
@@@@@
    @
@@@@@

@   @
@  @
@@@
@  @
@   @

@@@@@  @@@   @@@   @@@   @@@
  @   @   @ @   @ @   @ @   @
  @   @   @ @     @     @
  @   @   @ @   @ @   @ @   @
@@@@@  @@@   @@@   @@@   @@@
```

これは、endoh1.cの中に埋め込まれたLazy Kのコードを実行することで出力している（78行目、`K(I(I(I(...`で始まる行）。

## 解説

Lazy Kの詳細は[Wikipediaの記事](https://ja.wikipedia.org/wiki/Lazy_K)を参考のこと。

このプログラムは、SKIコンビネータを[call-by-need](https://ja.wikipedia.org/wiki/%E8%A9%95%E4%BE%A1%E6%88%A6%E7%95%A5)で評価する。
抽象構文木に次の規則を繰り返し適用することで、計算を行っていく。

* 構文木全体が`I x`になっていたら`x`に書き換える
* 構文木全体が`K x y`になっていたら`x`に書き換える
* 構文木全体が`S x y z`になっていたら`x z (y z)`に書き換える

コード形状はこの3つの規則をそのまま表現している。

---

基本的なアイデアは、SKIコンビネータの式をC言語の式として強引に解釈するところ。
次のマクロ定義が肝。

```
#define S (s)
#define K (k)
#define I (i)
```

これにより、たとえば`S (K I)`という式は`(s)((k)(i))`に置き換えられる。
これは普通のC言語で書くと`s(k(i))`となる。
関数`s`、`k`、`i`は構文木のノードを構築して返す。

---

SKIコンビネータをそのままC言語コードとして解釈するアイデアは単純だけれど、実現までには大きく3つの苦労があった。

1つめは、C言語に再帰型がないこと。
たとえば`S S S S S ....`という式は、`S(S)(S)(S)(S)...`と解釈されるので、先頭の`S`は関数ポインタで、返り値が関数ポインタで、その返り値も関数ポインタで、……というのを無限に繰り返す式でないといけない。
しかしC言語ではそういう型はないので、有限回（50段くらい）で我慢することにした。
それで足りない場合は、恒等関数を挟んで`I(I(S S S) S S S) S S S ...`とすれば回避できる。

2つめは、C言語でクロージャを表現すること。
`S K I`があったとき、`s(k)(i)`となるので、`s(k)`は呼び出し可能な関数を返さないと行けない。
しかし、決まった関数を返してしまうと、抽象構文木のノードとして区別できなくなってしまうので、一意な関数ポインタを返さなければならない。
どうしたかというと、グローバル変数と関数をたくさん定義しておいて、関数ポインタの配列にしておいて、それを順次取り出すことにした。
足りなくなったら残念だけど異常終了。

3つめは、サイズ制限。
埋め込んだLazy Kのコードが意外と場所をとるので、評価器部分はかなり圧縮されている。
これはhint.textにある通り、`s[]={0,0,s+6,s+2,s+4,s,s+3,s+5,s+1};`というテーブルが象徴的。
これを理解するには、抽象構文木の構造を理解する必要がある。

抽象構文木のノードは、`(ポインタ, ポインタ, ノードの種類)`という3要素のポインタで表現している。
ノードの種類に応じて、解釈が変わる。

* `s+0`のとき、関数適用（ポインタ2つはそれぞれ右の項と左の項）
* `s+1`のとき、`S`と解釈される（ポインタ2つは無視）
* `s+2`のとき、出力のためのダミーノードになる
* `s+3`のとき、`K`と解釈される
* `s+4`のとき、`I`と解釈される
* `s+5`のとき、数字の0のためのダミーノードになる
* `s+6`のとき、入力のためのダミーノードになる

ノードの種類の順番が不規則なのは、アリティチェックを簡単にするため。
1は引数3つのノード、2と3は引数2のノード、4と5と6は引数1のノードという順に並んでいるのでチェックが簡単になる。
なお、ノードの種類は実際には数字ではなく、配列へのポインタ`s`を足した値で表現される。

次に、`s[]={0,0,s+6,s+2,s+4,s,s+3,s+5,s+1};`というテーブルを解説する。
このテーブルは、特殊ノードを事前定義したテーブルになっている。

* ポインタ`s`は、`{ 0, 0, s+6 }`の3要素を指しているため、入力のためのダミーノードになる
* ポインタ`s+1`は、`{ 0, s+6, s+2 }`の3要素なので、出力のためのダミーノードになる（`0`と`s+6`は無視）
* ポインタ`s+2`は、`{ s+6, s+2, s+4 }`の3要素なので、`I`のノードになる
* ポインタ`s+3`は、`{ s+2, s+4, s }`の3要素なので、`K I`の関数適用ノードになる
* ポインタ`s+4`は、`{ s+4, s, s+3 }`の3要素なので、`K`のノードになる
* ポインタ`s+5`は、`{ s, s+3, s+5 }`の3要素なので、数字の0のためのダミーノードになる
* ポインタ`s+6`は、`{ s+3, s+5, s+1 }`の3要素なので、`S`のノードになる

ということで配列`s`の初期値は、3要素の窓をスライドしながら解釈するとすべてのプリミティブがみごとに詰まったものになっている。
`K I`がプリミティブとしてあるのは、数字のスコットエンコードで必要になるため。
入力ノードは読み込んだ値をポインタ部に保存するので、空いている必要がある。
数字の0のためのダミーノードは、最初のポインタが`s`である必要もあった。
これらの複雑な制約を満たすノードの種類と配列`s`の初期値は、SMTソルバで求めた。
