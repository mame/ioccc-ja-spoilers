---
id: 2015/duble
year: 2015
order: 3
authors: "Etienne_Duble"
orig_url: "https://www.ioccc.org/2015/duble/prog.c"
hint_url: "https://www.ioccc.org/2015/duble/hint.html"
title: "IOCCC 2015: Best Handwriting"
award_ja: "最高の手書き"
---

## 動作

Unicodeの点字を使って手書きフォントを表示する。

```
$ gcc -o prog prog.c

$ ./prog
> 
```

プロンプトが表示されるので、メッセージを入力する。

```
$ ./prog
> Hello, world!
```

改行を打つと、点字が点ごとに印字されて、手書きされている風のアニメーションとして表示される。

{% include img.html src="2015-duble-1.png" desc="表示中" %}

{% include img.html src="2015-duble-2.png" desc="表示完了" %}

次のようにprog.cを入力として与えると"segmentation fault"が点字で表示される。

```
$ ./prog < prog.c
```

{% include img.html src="2015-duble-3.png" desc="segmentation faultと表示された" %}

環境変数`DRAFT`を設定して起動すると、速くなる。
ただしフォントが少し粗くなる。

## 解説

対応している文字は`A`-`Z`と`.` `:` `,` `;` `!` `?`。大文字と小文字の区別はしない。

コード形状は"LOCK"と書かれた錠前と、 末尾にわかりやすく`main()`が置いてある。
これは、コード中のどのパートが難読化されているか（つまりほぼ全部）を示しているらしい。
なお、この`main()`の定義は明らかに偽物で、`#define main()`によって上書きされている。

プリプロセスを通すと、肥大化してわけがわからなくなる。
`Q_`と`mu`というマクロが邪悪で、`Q_(...)`は中身を125回繰り返すものになっている。
`Q({)`や`Q(})`はインデントを破壊するためだけなので`Q_`を取り除いて問題ないが、`Q_(O_o)`は取り除くと動かなくなる。

`if`文や三項演算子は使わず、再帰とショートカット演算子でフローが書かれている。
ただし、慎重に展開すれば`Q9-- || ...;`というようなコードの列であることがわかるので、`switch(Q9){...}`に直すことは比較的簡単。

prog.cを与えたときに"segmentation fault"と出るのは、`#`という文字を特別扱いしているため（prog.cは`#include`から始まることに注意）。
`echo "foo#bar" | ./prog`と実行すると"foosegmentation fault"と出るのでわかりやすい。
こういう工夫はとても良いと思う。

DRAFTモードは、`lrand48()`を使ってわざと出力を粗くする。
ただし`srand()`していないので、結果は固定になっている。

普通に起動した場合はプロンプトが出るが、標準入力にリダイレクトして起動した場合は出ない。
通常これは`isatty()`を使って判定されるが、このプログラムは`isatty()`を使っていない。
どうやってこの挙動を実現しているか、ということがクイズになっている。
答えを言うと、プロンプトは標準入力に`write()`されている。
パイプを通さず普通に起動した場合、標準入力への書き込みは標準出力に出るが、リダイレクトの場合は無視される、という挙動を活用したハック。
なおコード読解する際は、`dup()`や`dup2()`のトリックによって、標準入力が1番、標準出力が0番というようにファイルディスクリプタが差し替えられていることに注意。

フォントデータは[codes.txt](https://www.ioccc.org/2015/duble/codes.txt)に説明がある。
