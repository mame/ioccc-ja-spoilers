---
id: 2011/hou
year: 2011
order: 8
authors: "Qiming_HOU"
orig_url: "https://www.ioccc.org/2011/hou/hou.c"
hint_url: "https://www.ioccc.org/2011/hou/hint.html"
title: "IOCCC 2011: Best self documenting program"
award_ja: "最高の自己説明的なプログラム"
---

## 動作

関数電卓。

{: .wrap }
```
$ gcc -o hou hou.c -lm

$ ./hou 11/26+222/31
7168.000000

$ ./hou 'log((21701-19937)-(23209-21701))/log(2)'
-78.036946

$ ./hou 'sin(1.5708)+0.04321+log(sqrt(exp(1*1*1)))+(1+2*3)-0.4-0.6+(4+6)*(2-1+2*3)-tan(0.785398)+2*10/3*6*sqrt(16/2/2)*10+10000-1000'
10155.049091
```

## 解説

このコードはかなり驚異的。
コード形状は電卓だが、単なる見せかけではなく、このボタンの中身がきちんと意味のあるコードとして利用されている。
うばらしい。

例として書かれている`usage: calculator 11/26+222/31`や、その計算結果の`7.584,367`もコードとして意味のある数字になっている。
これらの数字を使いつつ、式の識別子を判別する値を計算で作り出す。
おそらくブルートフォースかなにかで都合の良い数字を探しだしたのだと思う。

そして、判別用の数字をデクリメントしつつ分岐し、電卓のアスキーアート中にある`tan`や`sqrt`を実際に関数名として使うことで関数を呼び出す（`tan`と`cos`と`sin`がバラバラの位置にあるのは判別用の数字の都合）。
また、`(/)`や`(+)`などもそれぞれの演算子を入力文字列からパースするために用いられている。
優先順位付きのパースは、`main`関数の第1引数をうまく使って行っている（と思う、詳細まで解読していない）。

制限としては、`argv[1]++`をするので`argv`が書き換え可能でないといけない（文字列自体は書き換えない）。
また、`1e-4`みたいな記法は動かない。
